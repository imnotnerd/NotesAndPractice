###  不重复最长子串 ###
<pre><code> public int lengthOfLongestSubstring(String s){
        int max=0;
        Map<Character,Integer> map = new HashMap<Character,Integer>();
        for(int i=0,j=0;i<s.length();i++){
            if(map.containsKey(s.charAt(i))){
                j=Math.max(j,map.get(s.charAt(i))+1);
            }
            map.put(s.charAt(i),i);
            max = Math.max(max,i-j+1);
        }
        return max;
    }</code></pre>
### 两个有序数组的中间数 ###
<pre><code>int k = (m + n + 1) / 2;
        double v = (double)FindKth(A, 0, m - 1, B, 0, n - 1, k);
        if ((m+n) % 2 == 0) {
            int k2 = k+1;
            double v2 = (double)FindKth(A, 0, m - 1, B, 0, n - 1, k2);
            v = (v + v2) / 2;
        }
        return v;
    }
    int FindKth(int[] A,int aL,int aR,int[] B,int bL,int bR,int k){
        if(aL>aR)return B[bL+k-1];
        if(bL>bR)return A[aL+k-1];
        int aMid = (aL+aR)>>1;
        int bMid = (bL+bR)>>1;
        if(A[aMid]<=B[bMid]){
            if(k<=(aMid-aL+bMid-bL+1)) {
                return FindKth(A, aL, aR, B, bL, bMid-1, k);
            }else{
                return FindKth(A,aMid+1,aR,B,bL,bR,k-(aMid-aL)-1);
            }
        }else{ //A[aMid]>B[bMid]
            if(k<=(aMid-aL+bMid-bL+1)) {
                return FindKth(A, aL, aMid-1, B, bMid, bR, k);
            }else{
                return FindKth(A,aL,aR,B,bL,bMid+1,k-(bMid-bL-1));
            }
        }
    }</code></pre>
假设 A[aMid]<=B[bMid];  x:mid len of a. y:mid len of b.可以得到
1.bMid前至少有x+y+1个元素。
2.aMid之后至少有(m-x-1+n-y)=m+n-(x+y+1)个元素。
因此
1.若k<=x+y1；在a b 中查找kth时无需考虑bMid以及其后的元素。
2.若k+x+y+1，找k-(x+1)个元素，无需考虑aMid以及其之前的元素。
### 旋转矩阵 ###
先对矩阵进行转置，然后flip the matrix horizontally.（顺时针）
逆时针时转置后 vertically
<pre><codoe>protected void Solution(int[][] matrix) {
        for(int i = 0; i<matrix.length; i++){
            for(int j = i; j<matrix[0].length; j++){
                int temp = 0;
                temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        for(int i =0 ; i<matrix.length; i++){
            for(int j = 0; j<matrix.length/2; j++){
                int temp = 0;
                temp = matrix[i][j];
                matrix[i][j] = matrix[i][matrix.length-1-j];
                matrix[i][matrix.length-1-j] = temp;
            }
        }
        }</code></pre>
### search range ###
存在重复元素的有序数组中查找某个target的范围。
<pre><code>  private int[] Solution(int[] nums,int target){

        int start = searchRange.firstGreaterEqual(nums, target);
        if (start == nums.length || nums[start] != target) {
            return new int[]{-1, -1};
        }
        return new int[]{start, searchRange.firstGreaterEqual(nums, target + 1) - 1};
    }
    private static int firstGreaterEqual(int[] A, int target) {
        int low = 0, high = A.length;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            //low <= mid < high
            if (A[mid] < target) {
                low = mid + 1;
            } else {
                //should not be mid-1 when A[mid]==target.
                //could be mid even if A[mid]>target because mid<high.
                high = mid;
            }
        }
        return low;
    }</code></pre>
思路：先查找第一个target元素的位置，再查找第一个target+1的位置，其间即为所求。在二分查找时与平时的二分查找不同，high=lengt   h
判断时if(A[mid]<target)low=mid+1;else{high=mid;}以保证找到第一个=target的元素的位置。
### Palindromic ###

### 数组中出现次数超过一半的数 ###
可以参考快排partition找到。
O(n)算法：在遍历数组时保存两个值，一个是数组中的一个数字，另一个是次数。当遍历下一个数时，若和保存的数相同，
，则数字加1,；不同则减1。如果次数为0，保存下一个数字并把次数设为1。最后一次把数字设为1时对应的数字就是所求数字。

<pre><code> public int Solution(int[] gifts,int n){
        if(n<=0||gifts.length<=0)return 0;
        int result=gifts[0],times=1;
        for(int i=1;i<n;i++){
            if(times==0){
                result=gifts[i];
                times=1;
            }else if(gifts[i]==result)times++;
            else times--;
        }
        times=0;
        //这里再循环一次判断当前result出现的次数
        for(int i=0,j=0;i<n;i++) {
            if (gifts[i]  == result) times++;
        }
        if(times>n/2)return result;
        return 0;
    }</code></pre>

### 第K小的数 ###
* O(n)的算法 仅当可以修改数组时
 基于Partition来查找。<pre><code>    private static int partition(int[] array, int beg, int end) {
            int first = array[beg];
            int i = beg, j = end;
            while (i < j) {
                while (array[i] <= first && i < end) {
                    i++;
                }
                while (array[j] > first && j >= beg) {
                    j--;
                }
                if (i < j) {
                    array[i] = array[i] ^ array[j];
                    array[j] = array[i] ^ array[j];
                    array[i] = array[i] ^ array[j];
                }
            }
            if (j != beg) {
                array[j] = array[beg] ^ array[j];
                array[beg] = array[beg] ^ array[j];
                array[j] = array[beg] ^ array[j];
            }
            return j;
        }</code></pre>
<pre><code>private static void quickSort(int[] array,int beg,int end){
        if(beg >= end || array == null)
            return;
        int p = partition(array, beg, end);
        quickSort(array, beg, p-1);
        quickSort(array, p+1, end);
    }</code></pre>
找第k小：
<pre><code> int getKth(int[] input,int k){
  int start=0,end=n-1;
  int index =partition(input,start,end);
  while(index!=k-1){
    if(index>k-1){
      end=index-1;
      index=partition(input,start,end);
    }else{
      start=index+1;
      index=partition(input,start,end);
    }
  }
  return input[index-1];
}
